package org.json;

/**
 * Extremely small JSON parser that can handle the structures generated by this extension.
 * It supports objects, arrays, strings, numbers, booleans and null values.
 */
class JsonParser {
    private final String input;
    private int index;

    private JsonParser(String input) {
        this.input = input;
        this.index = 0;
    }

    static Object parse(String input) {
        JsonParser parser = new JsonParser(input.trim());
        Object value = parser.parseValue();
        parser.skipWhitespace();
        if (parser.index != parser.input.length()) {
            throw new IllegalArgumentException("Trailing content after JSON value");
        }
        return value;
    }

    private Object parseValue() {
        skipWhitespace();
        if (index >= input.length()) {
            throw new IllegalArgumentException("Unexpected end of JSON string");
        }
        char ch = input.charAt(index);
        return switch (ch) {
            case '{' -> parseObject();
            case '[' -> parseArray();
            case '"' -> parseString();
            case 't' -> parseLiteral("true", Boolean.TRUE);
            case 'f' -> parseLiteral("false", Boolean.FALSE);
            case 'n' -> parseLiteral("null", null);
            default -> parseNumber();
        };
    }

    private JSONObject parseObject() {
        JSONObject obj = new JSONObject();
        index++; // skip '{'
        skipWhitespace();
        if (match('}')) {
            return obj;
        }
        while (true) {
            skipWhitespace();
            String key = parseString();
            skipWhitespace();
            if (!match(':')) {
                throw new IllegalArgumentException("Expected ':' after object key");
            }
            Object value = parseValue();
            obj.putValue(key, value);
            skipWhitespace();
            if (match('}')) {
                return obj;
            }
            if (!match(',')) {
                throw new IllegalArgumentException("Expected ',' between object entries");
            }
        }
    }

    private JSONArray parseArray() {
        JSONArray arr = new JSONArray();
        index++; // skip '['
        skipWhitespace();
        if (match(']')) {
            return arr;
        }
        while (true) {
            Object value = parseValue();
            arr.put(value);
            skipWhitespace();
            if (match(']')) {
                return arr;
            }
            if (!match(',')) {
                throw new IllegalArgumentException("Expected ',' between array elements");
            }
        }
    }

    private String parseString() {
        if (!match('"')) {
            throw new IllegalArgumentException("Expected string starting with \"");
        }
        StringBuilder sb = new StringBuilder();
        while (index < input.length()) {
            char ch = input.charAt(index++);
            if (ch == '"') {
                return sb.toString();
            }
            if (ch == '\\') {
                if (index >= input.length()) {
                    throw new IllegalArgumentException("Unterminated escape sequence");
                }
                char esc = input.charAt(index++);
                switch (esc) {
                    case '"', '\\', '/' -> sb.append(esc);
                    case 'b' -> sb.append('\b');
                    case 'f' -> sb.append('\f');
                    case 'n' -> sb.append('\n');
                    case 'r' -> sb.append('\r');
                    case 't' -> sb.append('\t');
                    case 'u' -> {
                        if (index + 4 > input.length()) {
                            throw new IllegalArgumentException("Invalid unicode escape");
                        }
                        String hex = input.substring(index, index + 4);
                        sb.append((char) Integer.parseInt(hex, 16));
                        index += 4;
                    }
                    default -> throw new IllegalArgumentException("Invalid escape sequence: \\" + esc);
                }
            } else {
                sb.append(ch);
            }
        }
        throw new IllegalArgumentException("Unterminated string literal");
    }

    private Object parseNumber() {
        int start = index;
        if (input.charAt(index) == '-') {
            index++;
        }
        while (index < input.length() && Character.isDigit(input.charAt(index))) {
            index++;
        }
        if (index < input.length() && input.charAt(index) == '.') {
            index++;
            while (index < input.length() && Character.isDigit(input.charAt(index))) {
                index++;
            }
        }
        if (index < input.length() && (input.charAt(index) == 'e' || input.charAt(index) == 'E')) {
            index++;
            if (index < input.length() && (input.charAt(index) == '+' || input.charAt(index) == '-')) {
                index++;
            }
            while (index < input.length() && Character.isDigit(input.charAt(index))) {
                index++;
            }
        }
        String number = input.substring(start, index);
        if (number.contains(".") || number.contains("e") || number.contains("E")) {
            return Double.parseDouble(number);
        }
        try {
            return Integer.parseInt(number);
        } catch (NumberFormatException ex) {
            return Long.parseLong(number);
        }
    }

    private Object parseLiteral(String literal, Object value) {
        if (input.regionMatches(index, literal, 0, literal.length())) {
            index += literal.length();
            return value;
        }
        throw new IllegalArgumentException("Expected literal '" + literal + "'");
    }

    private void skipWhitespace() {
        while (index < input.length()) {
            char ch = input.charAt(index);
            if (!Character.isWhitespace(ch)) {
                break;
            }
            index++;
        }
    }

    private boolean match(char expected) {
        if (index < input.length() && input.charAt(index) == expected) {
            index++;
            return true;
        }
        return false;
    }
}
